{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-7c156c85-5416-4fcd-9e6b-727c586be060",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Avoid Leaving Debug Code in Production\" vulnerability in C++ arises when developers inadvertently leave debugging code, such as logging, assertions, or test hooks, in the production environment. This can lead to several issues, including performance degradation, information leakage, and unintended behavior. Debug code is typically meant for development and testing purposes and should be removed or disabled in production builds.\n\n### General Mitigation Advice\n\n1. **Code Review**: Conduct thorough code reviews to ensure that debug code is not present in production.\n2. **Build Configurations**: Use different build configurations for development and production. Ensure that debug code is only included in development builds.\n3. **Conditional Compilation**: Use preprocessor directives to include debug code only in non-production builds.\n4. **Automated Tools**: Utilize static analysis tools to detect and flag debug code in the codebase.\n\n### Source Code Fix Recommendation\n\nTo address the specific vulnerability sink `127.0.0.1`, ensure that any debug code related to network operations, such as connecting to localhost for testing, is removed or conditionally compiled out in production builds.\n\n#### Example Code\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Library dependencies\n#include <boost/asio.hpp>\n\nint main() {\n    // Debug code: connecting to localhost\n#ifdef DEBUG\n    std::string debug_ip = \"127.0.0.1\";\n    std::cout << \"Connecting to debug IP: \" << debug_ip << std::endl;\n    // Simulate network operation\n    boost::asio::io_context io_context;\n    boost::asio::ip::tcp::resolver resolver(io_context);\n    boost::asio::ip::tcp::resolver::query query(debug_ip, \"80\");\n    boost::asio::ip::tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n    // ... additional debug operations\n#endif\n\n    // Production code\n    std::cout << \"Running production code...\" << std::endl;\n    // ... production operations\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `boost/asio.hpp`: This library is required for network operations in the example code. Ensure that Boost is properly installed and linked in your project.\n\n### Relevant Links\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "glog-b308b61f-b802-43a1-aacd-c8ec3db4dea3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`data_len`) is larger than the size of the destination buffer (`ptr`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer against the size of the source data before the `memcpy` operation. \n\nAlso, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11) which are designed to prevent buffer overflow by including the size of the destination buffer as a parameter.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (data_len <= sizeof(ptr)) {\n    memcpy(ptr, data, data_len);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the data to be copied is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-89750611-62a4-4e44-b483-f0676d7a5ee6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied (`data_len`) is larger than the size of the destination buffer (`ptr`). This can lead to overwriting of adjacent memory and can cause unexpected behavior including memory corruption, crashes, and the potential for execution of arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer against the size of the source data before the `memcpy` operation. \n\nAlso, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11) which are designed to prevent buffer overflow by including the size of the destination buffer as a parameter.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (data_len <= sizeof(ptr)) {\n    memcpy(ptr, data, data_len);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we first check if the size of the data to be copied is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy` operation. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-af989681-d7cc-487d-9fb0-7d0d368c3a20",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `curr->length()` is larger than the size of `combinedRange.data()`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t length = curr->length();\nif (combinedRange.size() >= length) {\n    memcpy(combinedRange.data(), curr->data(), length);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\nIn this fix, we first check if the size of `combinedRange` is large enough to hold the data from `curr`. If it is, we proceed with the `memcpy`. If it is not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-7c156c85-5416-4fcd-9e6b-727c586be060",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Avoid Leaving Debug Code in Production"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "contrib/dynamic_embedding/src/tde/details/io_redis_test.cpp"
                },
                "region": {
                  "startLine": 22,
                  "startColumn": 17,
                  "endLine": 22,
                  "endColumn": 26,
                  "charOffset": 562,
                  "charLength": 9,
                  "snippet": {
                    "text": "127.0.0.1",
                    "rendered": {
                      "text": "127.0.0.1",
                      "markdown": "`127.0.0.1`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "glog-b308b61f-b802-43a1-aacd-c8ec3db4dea3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "contrib/dynamic_embedding/src/tde/details/io.cpp"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 2,
                  "endLine": 63,
                  "endColumn": 29,
                  "charOffset": 1728,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(ptr, data, data_len)",
                    "rendered": {
                      "text": "memcpy(ptr, data, data_len)",
                      "markdown": "`memcpy(ptr, data, data_len)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "contrib/dynamic_embedding/src/tde/details/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1728,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr, <size of ptr>,  data,  data_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-89750611-62a4-4e44-b483-f0676d7a5ee6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "torchrec/csrc/dynamic_embedding/details/io.cpp"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 2,
                  "endLine": 71,
                  "endColumn": 29,
                  "charOffset": 1977,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(ptr, data, data_len)",
                    "rendered": {
                      "text": "memcpy(ptr, data, data_len)",
                      "markdown": "`memcpy(ptr, data, data_len)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "torchrec/csrc/dynamic_embedding/details/io.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1977,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(ptr, <size of ptr>,  data,  data_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-af989681-d7cc-487d-9fb0-7d0d368c3a20",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "torchrec/inference/src/Batching.cpp"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 13,
                  "endLine": 116,
                  "endColumn": 70,
                  "charOffset": 3704,
                  "charLength": 57,
                  "snippet": {
                    "text": "memcpy(combinedRange.data(), curr->data(), curr->length()",
                    "rendered": {
                      "text": "memcpy(combinedRange.data(), curr->data(), curr->length()",
                      "markdown": "`memcpy(combinedRange.data(), curr->data(), curr->length()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "torchrec/inference/src/Batching.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3704,
                        "charLength": 57
                      },
                      "insertedContent": {
                        "text": "memcpy_s(combinedRange.data(), <size of combinedRange.data()>,  curr->data(),  curr->length()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}